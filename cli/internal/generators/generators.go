// Package generators provides code generation for API, backend, and frontend services.
//
// Overview:
//   - Responsibility: Generate project scaffolding, API definitions, service templates
//   - Key Types: API generator, backend generator, frontend generator
//   - Concurrency Model: Sequential generation with atomic file writes
//   - Error Semantics: Generation errors with rollback support
//   - Performance Notes: Template-based generation, minimal I/O operations
//
// Usage:
//
//	apiGen := NewAPIGenerator(fs, runner)
//	err := apiGen.Init()
//	err := apiGen.Generate()
package generators

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"go.eggybyte.com/egg/cli/internal/configschema"
	"go.eggybyte.com/egg/cli/internal/projectfs"
	"go.eggybyte.com/egg/cli/internal/templates"
	"go.eggybyte.com/egg/cli/internal/toolrunner"
	"go.eggybyte.com/egg/cli/internal/ui"
)

// getFrameworkVersion returns the framework version to use for generated projects.
// This version is set during CLI release via cli-release.sh.
// For development builds, returns "latest" as fallback.
func getFrameworkVersion() string {
	// FrameworkVersion is defined in framework_version.go (generated by cli-release.sh)
	// For development builds, this file won't exist, so we use default
	// The framework_version.go file is generated during release and contains:
	// const FrameworkVersion = "v0.3.0"
	if FrameworkVersion != "" {
		return FrameworkVersion
	}
	return "latest"
}

// APIGenerator provides API definition generation.
//
// Parameters:
//   - fs: Project file system
//   - runner: Tool runner for external commands
//   - loader: Template loader
//
// Returns:
//   - None (data structure)
//
// Concurrency:
//   - Safe for concurrent use
//
// Performance:
//   - Template-based generation
type APIGenerator struct {
	fs     *projectfs.ProjectFS
	runner *toolrunner.Runner
	loader *templates.Loader
}

// BackendGenerator provides backend service generation.
//
// Parameters:
//   - fs: Project file system
//   - runner: Tool runner for external commands
//   - loader: Template loader
//
// Returns:
//   - None (data structure)
//
// Concurrency:
//   - Safe for concurrent use
//
// Performance:
//   - Template-based generation
type BackendGenerator struct {
	fs     *projectfs.ProjectFS
	runner *toolrunner.Runner
	loader *templates.Loader
}

// FrontendGenerator provides frontend service generation.
//
// Parameters:
//   - fs: Project file system
//   - runner: Tool runner for external commands
//
// Returns:
//   - None (data structure)
//
// Concurrency:
//   - Safe for concurrent use
//
// Performance:
//   - Template-based generation
type FrontendGenerator struct {
	fs     *projectfs.ProjectFS
	runner *toolrunner.Runner
}

// NewAPIGenerator creates a new API generator.
//
// Parameters:
//   - fs: Project file system
//   - runner: Tool runner for external commands
//
// Returns:
//   - *APIGenerator: API generator instance
//
// Concurrency:
//   - Safe for concurrent use
//
// Performance:
//   - Minimal initialization overhead
func NewAPIGenerator(fs *projectfs.ProjectFS, runner *toolrunner.Runner) *APIGenerator {
	return &APIGenerator{
		fs:     fs,
		runner: runner,
		loader: templates.NewLoader(),
	}
}

// NewBackendGenerator creates a new backend generator.
//
// Parameters:
//   - fs: Project file system
//   - runner: Tool runner for external commands
//
// Returns:
//   - *BackendGenerator: Backend generator instance
//
// Concurrency:
//   - Safe for concurrent use
//
// Performance:
//   - Minimal initialization overhead
func NewBackendGenerator(fs *projectfs.ProjectFS, runner *toolrunner.Runner) *BackendGenerator {
	return &BackendGenerator{
		fs:     fs,
		runner: runner,
		loader: templates.NewLoader(),
	}
}

// NewFrontendGenerator creates a new frontend generator.
//
// Parameters:
//   - fs: Project file system
//   - runner: Tool runner for external commands
//
// Returns:
//   - *FrontendGenerator: Frontend generator instance
//
// Concurrency:
//   - Safe for concurrent use
//
// Performance:
//   - Minimal initialization overhead
func NewFrontendGenerator(fs *projectfs.ProjectFS, runner *toolrunner.Runner) *FrontendGenerator {
	return &FrontendGenerator{
		fs:     fs,
		runner: runner,
	}
}

// Init initializes API definitions and configuration.
//
// Parameters:
//   - ctx: Context for cancellation
//
// Returns:
//   - error: Initialization error if any
//
// Concurrency:
//   - Single-threaded
//
// Performance:
//   - File creation and tool execution
func (g *APIGenerator) Init(ctx context.Context) error {
	ui.Info("Initializing API definitions...")

	// Create API directory structure
	if err := g.fs.CreateDirectory("api"); err != nil {
		return fmt.Errorf("failed to create api directory: %w", err)
	}

	// Write buf.yaml from template
	bufYAML, err := g.loader.LoadTemplate("api/buf.yaml.tmpl")
	if err != nil {
		return fmt.Errorf("failed to load buf.yaml template: %w", err)
	}
	if err := g.fs.WriteFile("api/buf.yaml", bufYAML, 0644); err != nil {
		return fmt.Errorf("failed to write buf.yaml: %w", err)
	}

	// Write buf.gen.yaml from template
	bufGenYAML, err := g.loader.LoadTemplate("api/buf.gen.yaml.tmpl")
	if err != nil {
		return fmt.Errorf("failed to load buf.gen.yaml template: %w", err)
	}
	if err := g.fs.WriteFile("api/buf.gen.yaml", bufGenYAML, 0644); err != nil {
		return fmt.Errorf("failed to write buf.gen.yaml: %w", err)
	}

	// Note: gen directories will be created automatically by buf generate
	ui.Success("API definitions initialized")
	return nil
}

// Generate generates code from API definitions.
//
// Parameters:
//   - ctx: Context for cancellation
//
// Returns:
//   - error: Generation error if any
//
// Concurrency:
//   - Single-threaded
//
// Performance:
//   - Code generation time depends on protobuf complexity
func (g *APIGenerator) Generate(ctx context.Context) error {
	ui.Info("Generating code from API definitions...")

	// Change to api directory
	apiRunner := toolrunner.NewRunner(filepath.Join(g.fs.GetRootDir(), "api"))
	apiRunner.SetVerbose(true)

	// Run buf generate
	if err := apiRunner.BufGenerate(ctx); err != nil {
		return fmt.Errorf("failed to generate code with buf: %w", err)
	}

	// Initialize gen/go/go.mod for generated code if it doesn't exist
	if err := g.ensureGenGoMod(ctx); err != nil {
		return fmt.Errorf("failed to initialize gen/go module: %w", err)
	}

	// Add gen/go module to backend workspace
	if err := g.addGenGoToBackendWorkspace(ctx); err != nil {
		return fmt.Errorf("failed to add gen/go to backend workspace: %w", err)
	}

	// Update existing backend services with gen/go replace directive
	if err := g.updateBackendServicesWithGenGo(ctx); err != nil {
		ui.Warning("Failed to update backend services with gen/go: %v", err)
	}

	ui.Success("Code generation completed")
	return nil
}

// ensureGenGoMod initializes gen/go/go.mod if it doesn't exist.
//
// Parameters:
//   - ctx: Context for cancellation
//
// Returns:
//   - error: Initialization error if any
//
// Concurrency:
//   - Single-threaded
//
// Performance:
//   - File system check and go mod init
func (g *APIGenerator) ensureGenGoMod(ctx context.Context) error {
	genGoDir := filepath.Join(g.fs.GetRootDir(), "gen", "go")
	goModPath := filepath.Join(genGoDir, "go.mod")

	// Check if gen/go/go.mod already exists
	if _, err := os.Stat(goModPath); err == nil {
		// go.mod already exists, just tidy it
		genGoRunner := toolrunner.NewRunner(genGoDir)
		genGoRunner.SetVerbose(false)
		if err := genGoRunner.GoModTidy(ctx); err != nil {
			ui.Warning("Failed to tidy gen/go/go.mod: %v", err)
		}
		return nil
	}

	// Check if gen/go directory exists (created by buf generate)
	if _, err := os.Stat(genGoDir); os.IsNotExist(err) {
		// No generated code yet, skip
		ui.Info("No generated code yet, skipping gen/go/go.mod creation")
		return nil
	}

	// Load egg.yaml to get module prefix
	configPath := filepath.Join(g.fs.GetRootDir(), "egg.yaml")
	configData, err := os.ReadFile(configPath)
	if err != nil {
		return fmt.Errorf("failed to read egg.yaml: %w", err)
	}

	// Extract module_prefix from yaml (simple string search)
	modulePrefix := ""
	lines := strings.Split(string(configData), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "module_prefix:") {
			modulePrefix = strings.TrimSpace(strings.TrimPrefix(line, "module_prefix:"))
			modulePrefix = strings.Trim(modulePrefix, `"`)
			break
		}
	}
	if modulePrefix == "" {
		return fmt.Errorf("module_prefix not found in egg.yaml")
	}

	// Initialize gen/go/go.mod
	ui.Info("Initializing gen/go/go.mod for generated code...")
	genGoRunner := toolrunner.NewRunner(genGoDir)
	genGoRunner.SetVerbose(true)
	genGoModulePath := modulePrefix + "/gen/go"
	if err := genGoRunner.GoModInit(ctx, genGoModulePath); err != nil {
		return fmt.Errorf("failed to initialize gen/go/go.mod: %w", err)
	}

	// Tidy to add dependencies from generated code
	if err := genGoRunner.GoModTidy(ctx); err != nil {
		ui.Warning("Failed to tidy gen/go/go.mod: %v", err)
	}

	ui.Success("gen/go module initialized: %s", genGoModulePath)
	return nil
}

// addGenGoToBackendWorkspace adds gen/go module to backend/go.work.
//
// Parameters:
//   - ctx: Context for cancellation
//
// Returns:
//   - error: Addition error if any
//
// Concurrency:
//   - Single-threaded
//
// Performance:
//   - File system check and go work use
func (g *APIGenerator) addGenGoToBackendWorkspace(ctx context.Context) error {
	// Check if backend/go.work exists
	goWorkPath := filepath.Join(g.fs.GetRootDir(), "backend", "go.work")
	if _, err := os.Stat(goWorkPath); err != nil {
		// go.work doesn't exist yet, skip
		ui.Info("backend/go.work not found, skipping workspace update")
		return nil
	}

	// Check if gen/go/go.mod exists
	genGoModPath := filepath.Join(g.fs.GetRootDir(), "gen", "go", "go.mod")
	if _, err := os.Stat(genGoModPath); err != nil {
		// gen/go/go.mod doesn't exist yet, skip
		return nil
	}

	// Add ../gen/go to backend workspace
	ui.Info("Adding gen/go to backend workspace...")
	backendRunner := toolrunner.NewRunner(filepath.Join(g.fs.GetRootDir(), "backend"))
	backendRunner.SetVerbose(false)
	if _, err := backendRunner.Go(ctx, "work", "use", "../gen/go"); err != nil {
		ui.Warning("Failed to add gen/go to workspace: %v", err)
	}

	return nil
}

// updateBackendServicesWithGenGo adds gen/go replace directive to all existing backend services.
//
// Parameters:
//   - ctx: Context for cancellation
//
// Returns:
//   - error: Update error if any
//
// Concurrency:
//   - Single-threaded
//
// Performance:
//   - Iterates through backend directory and updates each service
func (g *APIGenerator) updateBackendServicesWithGenGo(ctx context.Context) error {
	// Get module prefix from egg.yaml
	configPath := filepath.Join(g.fs.GetRootDir(), "egg.yaml")
	configData, err := os.ReadFile(configPath)
	if err != nil {
		return fmt.Errorf("failed to read egg.yaml: %w", err)
	}

	modulePrefix := ""
	lines := strings.Split(string(configData), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "module_prefix:") {
			modulePrefix = strings.TrimSpace(strings.TrimPrefix(line, "module_prefix:"))
			modulePrefix = strings.Trim(modulePrefix, `"`)
			break
		}
	}
	if modulePrefix == "" {
		return fmt.Errorf("module_prefix not found in egg.yaml")
	}

	// Get gen/go absolute path (relative to service directory)
	genGoModulePath := fmt.Sprintf("%s/gen/go", modulePrefix)

	// Check if gen/go exists
	genGoModPath := filepath.Join(g.fs.GetRootDir(), "gen", "go", "go.mod")
	if _, err := os.Stat(genGoModPath); err != nil {
		// gen/go doesn't exist yet, skip
		return nil
	}

	// Find all backend services
	backendDir := filepath.Join(g.fs.GetRootDir(), "backend")
	entries, err := os.ReadDir(backendDir)
	if err != nil {
		// backend directory doesn't exist, skip
		return nil
	}

	// Update each backend service
	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}

		serviceDir := filepath.Join(backendDir, entry.Name())
		goModPath := filepath.Join(serviceDir, "go.mod")
		if _, err := os.Stat(goModPath); err != nil {
			// No go.mod in this directory, skip
			continue
		}

		// Calculate relative path from service directory to gen/go
		// backend/user -> ../../gen/go
		genGoRelPath := "../../gen/go"

		// Add replace directive with relative path
		serviceRunner := toolrunner.NewRunner(serviceDir)
		serviceRunner.SetVerbose(false)
		if _, err := serviceRunner.Go(ctx, "mod", "edit", "-replace", fmt.Sprintf("%s=%s", genGoModulePath, genGoRelPath)); err != nil {
			ui.Warning("Failed to add gen/go replace directive for service %s: %v", entry.Name(), err)
			continue
		}

		// Run go mod tidy to apply changes
		if err := serviceRunner.GoModTidy(ctx); err != nil {
			ui.Warning("Failed to tidy service %s after adding gen/go replace: %v", entry.Name(), err)
		}
	}

	return nil
}

// Create creates a new backend service.
//
// Parameters:
//   - ctx: Context for cancellation
//   - name: Service name
//   - config: Project configuration
//   - protoTemplate: Proto template type (echo, crud, or none)
//   - useLocalModules: Whether to use local egg modules for development
//
// Returns:
//   - error: Creation error if any
//
// Concurrency:
//   - Single-threaded
//
// Performance:
//   - Service scaffolding and module initialization
func (g *BackendGenerator) Create(ctx context.Context, name string, config *configschema.Config, protoTemplate string, useLocalModules bool) error {
	ui.Info("Creating backend service: %s", name)

	// Validate service name
	if !isValidServiceName(name) {
		return fmt.Errorf("invalid service name: %s", name)
	}

	// Create service directory structure
	serviceDir := filepath.Join("backend", name)
	if err := g.fs.CreateDirectory(serviceDir); err != nil {
		return fmt.Errorf("failed to create service directory: %w", err)
	}

	// Create cmd/server directory
	cmdDir := filepath.Join(serviceDir, "cmd", "server")
	if err := g.fs.CreateDirectory(cmdDir); err != nil {
		return fmt.Errorf("failed to create cmd directory: %w", err)
	}

	// Create internal directory structure
	internalDirs := []string{
		filepath.Join(serviceDir, "internal", "config"),
		filepath.Join(serviceDir, "internal", "handler"),
		filepath.Join(serviceDir, "internal", "model"),
		filepath.Join(serviceDir, "internal", "repository"),
		filepath.Join(serviceDir, "internal", "service"),
	}
	for _, dir := range internalDirs {
		if err := g.fs.CreateDirectory(dir); err != nil {
			return fmt.Errorf("failed to create internal directory %s: %w", dir, err)
		}
	}

	// Get service configuration
	serviceConfig, exists := config.Backend[name]
	if !exists {
		return fmt.Errorf("service configuration not found: %s", name)
	}

	// Initialize Go module
	modulePath := fmt.Sprintf("%s/backend/%s", config.ModulePrefix, name)
	serviceRunner := toolrunner.NewRunner(filepath.Join(g.fs.GetRootDir(), serviceDir))
	serviceRunner.SetVerbose(true)

	if err := serviceRunner.GoModInit(ctx, modulePath); err != nil {
		return fmt.Errorf("failed to initialize Go module: %w", err)
	}

	// Add egg dependencies
	if useLocalModules {
		// Use local dev versions for development (no replace directives for Docker compatibility)
		ui.Info("Adding local egg modules for development...")

		// Use v0.0.0-dev version which will resolve from local workspace
		// This works both locally and in Docker builds
		requiredDeps := []string{
			"go.eggybyte.com/egg/core@v0.0.0-dev",
			"go.eggybyte.com/egg/logx@v0.0.0-dev",
			"go.eggybyte.com/egg/configx@v0.0.0-dev",
			"go.eggybyte.com/egg/obsx@v0.0.0-dev",
			"go.eggybyte.com/egg/connectx@v0.0.0-dev",
			"go.eggybyte.com/egg/runtimex@v0.0.0-dev",
			"go.eggybyte.com/egg/servicex@v0.0.0-dev",
			"go.eggybyte.com/egg/storex@v0.0.0-dev",
			"connectrpc.com/connect@latest",
			"gorm.io/gorm@latest",
			"gorm.io/driver/mysql@latest",
			"github.com/google/uuid@latest",
		}
		for _, dep := range requiredDeps {
			// Use GOPROXY=direct GOSUMDB=off to fetch from local modules
			if _, err := serviceRunner.GoWithEnv(ctx, map[string]string{
				"GOPROXY": "direct",
				"GOSUMDB": "off",
			}, "get", dep); err != nil {
				ui.Warning("Failed to add dependency %s: %v", dep, err)
				continue
			}
		}
	} else {
		// Use published modules with framework version from CLI release
		ui.Info("Using published egg modules...")

		// Get framework version set during CLI release
		frameworkVersion := getFrameworkVersion()
		if frameworkVersion == "latest" {
			ui.Warning("Using 'latest' framework version (development build). Published CLI releases will use specific versions.")
		}

		eggDeps := []string{
			fmt.Sprintf("go.eggybyte.com/egg/core@%s", frameworkVersion),
			fmt.Sprintf("go.eggybyte.com/egg/logx@%s", frameworkVersion),
			fmt.Sprintf("go.eggybyte.com/egg/configx@%s", frameworkVersion),
			fmt.Sprintf("go.eggybyte.com/egg/obsx@%s", frameworkVersion),
			fmt.Sprintf("go.eggybyte.com/egg/connectx@%s", frameworkVersion),
			fmt.Sprintf("go.eggybyte.com/egg/runtimex@%s", frameworkVersion),
			fmt.Sprintf("go.eggybyte.com/egg/servicex@%s", frameworkVersion),
			fmt.Sprintf("go.eggybyte.com/egg/storex@%s", frameworkVersion),
		}
		thirdPartyDeps := []string{
			"connectrpc.com/connect@latest",
			"gorm.io/gorm@latest",
			"gorm.io/driver/mysql@latest",
			"github.com/google/uuid@latest",
		}

		// Add egg dependencies with GOPROXY=direct to avoid proxy issues
		// Egg modules should be fetched directly from source repository
		ui.Info("Adding egg framework dependencies (GOPROXY=direct)...")
		for _, dep := range eggDeps {
			if _, err := serviceRunner.GoWithEnv(ctx, map[string]string{"GOPROXY": "direct"}, "get", dep); err != nil {
				ui.Warning("Failed to add dependency %s: %v", dep, err)
				continue
			}
		}

		// Add third-party dependencies with default proxy
		ui.Info("Adding third-party dependencies...")
		for _, dep := range thirdPartyDeps {
			if _, err := serviceRunner.Go(ctx, "get", dep); err != nil {
				ui.Warning("Failed to add dependency %s: %v", dep, err)
				continue
			}
		}
	}

	// Add gen/go replace directive if it exists (should exist after proto generation)
	genGoModPath := filepath.Join(g.fs.GetRootDir(), "gen", "go", "go.mod")
	if _, err := os.Stat(genGoModPath); err == nil {
		// gen/go exists, add replace directive with relative path
		// backend/user -> ../../gen/go
		genGoRelPath := "../../gen/go"
		genGoModulePath := fmt.Sprintf("%s/gen/go", config.ModulePrefix)
		if _, err := serviceRunner.Go(ctx, "mod", "edit", "-replace", fmt.Sprintf("%s=%s", genGoModulePath, genGoRelPath)); err != nil {
			ui.Warning("Failed to add replace directive for gen/go: %v", err)
		} else {
			ui.Info("Added gen/go replace directive to service go.mod")
		}
	}

	// Prepare template data
	templateData := g.prepareTemplateData(name, serviceConfig, config, protoTemplate)

	// Generate proto file if requested
	if protoTemplate != "none" {
		if err := g.generateProtoFile(name, protoTemplate, templateData); err != nil {
			return fmt.Errorf("failed to generate proto file: %w", err)
		}
	}

	// Generate service files
	if err := g.generateBackendFiles(name, serviceConfig, config, templateData); err != nil {
		return fmt.Errorf("failed to generate service files: %w", err)
	}

	// Note: Makefile generation removed - use egg CLI build commands instead

	// Update backend go.work first (needed for tidy to resolve local modules)
	if err := g.updateBackendWorkspace(ctx, name, config); err != nil {
		return fmt.Errorf("failed to update workspace: %w", err)
	}

	// Generate proto code if proto file was created
	if protoTemplate != "none" {
		ui.Info("Generating code from proto definitions...")
		apiRunner := toolrunner.NewRunner(filepath.Join(g.fs.GetRootDir(), "api"))
		apiRunner.SetVerbose(true)
		if err := apiRunner.BufGenerate(ctx); err != nil {
			ui.Warning("buf generate failed: %v", err)
			ui.Warning("Proto code generation failed - some services may have missing imports")
			// Continue anyway - service might not need proto code yet
			// Note: This may result in compilation errors if proto code is required
		} else {
			ui.Success("Proto code generated successfully")

			// Initialize gen/go/go.mod if it doesn't exist
			genGoDir := filepath.Join(g.fs.GetRootDir(), "gen", "go")
			goModPath := filepath.Join(genGoDir, "go.mod")
			if _, err := os.Stat(goModPath); os.IsNotExist(err) {
				// gen/go directory should exist after buf generate
				if _, err := os.Stat(genGoDir); err == nil {
					ui.Info("Initializing gen/go/go.mod for generated code...")
					genGoRunner := toolrunner.NewRunner(genGoDir)
					genGoRunner.SetVerbose(false)
					genGoModulePath := fmt.Sprintf("%s/gen/go", config.ModulePrefix)
					if err := genGoRunner.GoModInit(ctx, genGoModulePath); err != nil {
						ui.Warning("Failed to initialize gen/go/go.mod: %v", err)
					} else {
						// Tidy to add dependencies from generated code
						if err := genGoRunner.GoModTidy(ctx); err != nil {
							ui.Warning("Failed to tidy gen/go/go.mod: %v", err)
						} else {
							ui.Success("gen/go module initialized: %s", genGoModulePath)
						}
					}
				}
			}

			// Add gen/go replace directive to service go.mod after initialization
			if _, err := os.Stat(goModPath); err == nil {
				genGoRelPath := "../../gen/go"
				genGoModulePath := fmt.Sprintf("%s/gen/go", config.ModulePrefix)
				if _, err := serviceRunner.Go(ctx, "mod", "edit", "-replace", fmt.Sprintf("%s=%s", genGoModulePath, genGoRelPath)); err != nil {
					ui.Warning("Failed to add replace directive for gen/go: %v", err)
				} else {
					ui.Info("Added gen/go replace directive to service go.mod")
				}
			}
		}
	}

	// Tidy module after generating files with imports
	// Note: This may fail if proto-generated imports are missing, but we continue
	if useLocalModules {
		// Use GOPROXY=direct GOSUMDB=off for local development
		if _, err := serviceRunner.GoWithEnv(ctx, map[string]string{
			"GOPROXY": "direct",
			"GOSUMDB": "off",
		}, "mod", "tidy"); err != nil {
			ui.Warning("go mod tidy failed: %v", err)
			ui.Warning("This may indicate missing proto-generated code or import issues")
			ui.Warning("Try running 'egg api generate' manually if needed")
			// Don't fail - service structure is created, user can fix imports
		}
	} else {
		if err := serviceRunner.GoModTidy(ctx); err != nil {
			ui.Warning("go mod tidy failed: %v", err)
			ui.Warning("This may indicate missing proto-generated code or import issues")
			ui.Warning("Try running 'egg api generate' manually if needed")
			// Don't fail - service structure is created, user can fix imports
		}
	}

	ui.Success("Backend service created: %s", name)
	return nil
}

// generateBackendFiles generates the backend service files.
//
// Parameters:
//   - name: Service name
//   - serviceConfig: Service configuration
//   - config: Project configuration
//   - templateData: Template data for rendering
//
// Returns:
//   - error: Generation error if any
//
// Concurrency:
//   - Single-threaded
//
// Performance:
//   - Template-based file generation
func (g *BackendGenerator) generateBackendFiles(name string, serviceConfig configschema.BackendService, config *configschema.Config, templateData *TemplateData) error {
	// Convert TemplateData to map for compatibility with loader.LoadAndRender
	data := map[string]interface{}{
		"ModulePrefix":      templateData.ModulePrefix,
		"ServiceModulePath": templateData.ServiceModulePath,
		"ServiceName":       templateData.ServiceName,
		"ServiceNameCamel":  templateData.ServiceNameCamel,
		"ServiceNameVar":    templateData.ServiceNameVar,
		"ProtoPackage":      templateData.ProtoPackage,
		"BinaryName":        templateData.BinaryName,
		"HTTPPort":          templateData.HTTPPort,
		"HealthPort":        templateData.HealthPort,
		"MetricsPort":       templateData.MetricsPort,
		"ProtoTemplate":     templateData.ProtoTemplate,
		"HasDatabase":       templateData.ProtoTemplate == "crud",
	}

	// Generate main.go from template
	mainGo, err := g.loader.LoadAndRender("backend/main.go.tmpl", data)
	if err != nil {
		return fmt.Errorf("failed to load and render main.go template: %w", err)
	}
	if err := g.fs.WriteFile(filepath.Join("backend", name, "cmd", "server", "main.go"), mainGo, 0644); err != nil {
		return fmt.Errorf("failed to write main.go: %w", err)
	}

	// Generate config/app_config.go from template
	appConfigGo, err := g.loader.LoadAndRender("backend/app_config.go.tmpl", data)
	if err != nil {
		return fmt.Errorf("failed to load and render app_config.go template: %w", err)
	}
	if err := g.fs.WriteFile(filepath.Join("backend", name, "internal", "config", "app_config.go"), appConfigGo, 0644); err != nil {
		return fmt.Errorf("failed to write app_config.go: %w", err)
	}

	// Generate handler placeholder from template
	handlerGo, err := g.loader.LoadAndRender("backend/handler.go.tmpl", data)
	if err != nil {
		return fmt.Errorf("failed to load and render handler.go template: %w", err)
	}
	if err := g.fs.WriteFile(filepath.Join("backend", name, "internal", "handler", "handler.go"), handlerGo, 0644); err != nil {
		return fmt.Errorf("failed to write handler.go: %w", err)
	}

	// Generate model, repository, service, and errors only for CRUD templates
	if templateData.ProtoTemplate == "crud" {
		// Generate service placeholder from template
		serviceGo, err := g.loader.LoadAndRender("backend/service.go.tmpl", data)
		if err != nil {
			return fmt.Errorf("failed to load and render service.go template: %w", err)
		}
		if err := g.fs.WriteFile(filepath.Join("backend", name, "internal", "service", "service.go"), serviceGo, 0644); err != nil {
			return fmt.Errorf("failed to write service.go: %w", err)
		}

		// Generate model from template
		modelGo, err := g.loader.LoadAndRender("backend/model.go.tmpl", data)
		if err != nil {
			return fmt.Errorf("failed to load and render model.go template: %w", err)
		}
		if err := g.fs.WriteFile(filepath.Join("backend", name, "internal", "model", "model.go"), modelGo, 0644); err != nil {
			return fmt.Errorf("failed to write model.go: %w", err)
		}

		// Generate repository from template
		repositoryGo, err := g.loader.LoadAndRender("backend/repository.go.tmpl", data)
		if err != nil {
			return fmt.Errorf("failed to load and render repository.go template: %w", err)
		}
		if err := g.fs.WriteFile(filepath.Join("backend", name, "internal", "repository", "repository.go"), repositoryGo, 0644); err != nil {
			return fmt.Errorf("failed to write repository.go: %w", err)
		}

		// Generate errors from template
		errorsGo, err := g.loader.LoadAndRender("backend/errors.go.tmpl", data)
		if err != nil {
			return fmt.Errorf("failed to load and render errors.go template: %w", err)
		}
		if err := g.fs.WriteFile(filepath.Join("backend", name, "internal", "model", "errors.go"), errorsGo, 0644); err != nil {
			return fmt.Errorf("failed to write errors.go: %w", err)
		}
	}

	return nil
}

// updateBackendWorkspace updates the backend go.work file.
//
// Parameters:
//   - ctx: Context for cancellation
//   - name: Service name
//   - config: Project configuration
//
// Returns:
//   - error: Update error if any
//
// Concurrency:
//   - Single-threaded
//
// Performance:
//   - Workspace file update
func (g *BackendGenerator) updateBackendWorkspace(ctx context.Context, name string, config *configschema.Config) error {
	// Check if go.work exists
	workPath := filepath.Join("backend", "go.work")
	exists, err := g.fs.FileExists(workPath)
	if err != nil {
		return fmt.Errorf("failed to check go.work existence: %w", err)
	}

	backendRunner := toolrunner.NewRunner(filepath.Join(g.fs.GetRootDir(), "backend"))
	backendRunner.SetVerbose(true)

	if !exists {
		// Create new workspace in backend directory
		if err := backendRunner.GoWorkInit(ctx, fmt.Sprintf("./%s", name)); err != nil {
			return fmt.Errorf("failed to initialize workspace: %w", err)
		}
	} else {
		// Add to existing workspace
		if err := backendRunner.GoWorkUse(ctx, fmt.Sprintf("./%s", name)); err != nil {
			return fmt.Errorf("failed to add module to workspace: %w", err)
		}
	}

	return nil
}

// Create creates a new frontend service.
//
// Parameters:
//   - ctx: Context for cancellation
//   - name: Service name
//   - platforms: Target platforms (web, android, ios)
//   - config: Project configuration
//
// Returns:
//   - error: Creation error if any
//
// Concurrency:
//   - Single-threaded
//
// Performance:
//   - Flutter project creation
func (g *FrontendGenerator) Create(ctx context.Context, name string, platforms []string, config *configschema.Config) error {
	ui.Info("Creating frontend service: %s (platforms: %v)", name, platforms)

	// Validate service name
	if !isValidServiceName(name) {
		return fmt.Errorf("invalid service name: %s", name)
	}

	// Convert service name to valid Dart package name
	// Dart requires lowercase letters, numbers, and underscores only
	dartPackageName := dartifyServiceName(name)
	if dartPackageName != name {
		ui.Info("Converting service name to Dart-compatible package name: %s -> %s", name, dartPackageName)
	}

	// Validate Dart package name
	if !isValidDartPackageName(dartPackageName) {
		return fmt.Errorf("invalid Dart package name: %s (must use lowercase letters, numbers, and underscores only)", dartPackageName)
	}

	// Create Flutter project
	frontendRunner := toolrunner.NewRunner(filepath.Join(g.fs.GetRootDir(), "frontend"))
	frontendRunner.SetVerbose(true)

	if err := frontendRunner.FlutterCreate(ctx, dartPackageName, platforms); err != nil {
		return fmt.Errorf("failed to create Flutter project: %w", err)
	}

	ui.Success("Frontend service created: %s", dartPackageName)
	ui.Info("To use a specific Flutter version, use FVM: https://fvm.app")
	return nil
}

// GenerateCompose generates docker-compose.yaml for the project.
//
// Parameters:
//   - ctx: Context for cancellation
//   - config: Project configuration
//
// Returns:
//   - error: Generation error if any
//
// Concurrency:
//   - Single-threaded
//
// Performance:
//   - Template-based file generation
func (g *BackendGenerator) GenerateCompose(ctx context.Context, config *configschema.Config) error {
	ui.Info("Generating docker-compose configuration...")

	data := map[string]interface{}{
		"ProjectName":          config.ProjectName,
		"DockerRegistry":       config.DockerRegistry,
		"Version":              config.Version,
		"BackendServices":      config.Backend,
		"FrontendServices":     config.Frontend,
		"DatabaseEnabled":      config.Database.Enabled,
		"DatabaseImage":        config.Database.Image,
		"DatabasePort":         config.Database.Port,
		"DatabaseUser":         config.Database.User,
		"DatabasePassword":     config.Database.Password,
		"DatabaseRootPassword": config.Database.RootPassword,
		"DatabaseName":         config.Database.Database,
		"EnvGlobal":            config.Env.Global,
		"EnvBackend":           config.Env.Backend,
		"EnvFrontend":          config.Env.Frontend,
	}

	// Generate docker-compose.yaml from template
	composeYAML, err := g.loader.LoadAndRender("compose/docker-compose.yaml.tmpl", data)
	if err != nil {
		return fmt.Errorf("failed to load and render docker-compose.yaml template: %w", err)
	}
	if err := g.fs.WriteFile("deploy/compose/compose.yaml", composeYAML, 0644); err != nil {
		return fmt.Errorf("failed to write compose configuration: %w", err)
	}

	// Generate .env file
	if err := g.generateComposeEnvFile(config); err != nil {
		return fmt.Errorf("failed to generate .env file: %w", err)
	}

	// Generate Dockerfile.backend from template
	dockerfileBackend, err := g.loader.LoadAndRender("docker/Dockerfile.backend.tmpl", data)
	if err != nil {
		return fmt.Errorf("failed to load and render Dockerfile.backend template: %w", err)
	}
	if err := g.fs.WriteFile("docker/Dockerfile.backend", dockerfileBackend, 0644); err != nil {
		return fmt.Errorf("failed to write Dockerfile.backend: %w", err)
	}

	ui.Success("docker-compose configuration generated: deploy/compose/compose.yaml")
	return nil
}

// generateComposeEnvFile generates .env file for Docker Compose.
//
// Parameters:
//   - config: Project configuration
//
// Returns:
//   - error: Generation error if any
//
// Concurrency:
//   - Single-threaded
//
// Performance:
//   - File I/O operation
func (g *BackendGenerator) generateComposeEnvFile(config *configschema.Config) error {
	var builder strings.Builder

	// Compose project name
	builder.WriteString("COMPOSE_PROJECT_NAME=" + config.ProjectName + "\n")
	builder.WriteString("\n# Global Environment\n")

	// Global environment
	for key, value := range config.Env.Global {
		builder.WriteString(key + "=" + value + "\n")
	}

	// Backend environment
	if len(config.Env.Backend) > 0 {
		builder.WriteString("\n# Backend Environment\n")
		for key, value := range config.Env.Backend {
			builder.WriteString(key + "=" + value + "\n")
		}
	}

	// Frontend environment
	if len(config.Env.Frontend) > 0 {
		builder.WriteString("\n# Frontend Environment\n")
		for key, value := range config.Env.Frontend {
			builder.WriteString(key + "=" + value + "\n")
		}
	}

	// Database environment
	if config.Database.Enabled {
		builder.WriteString("\n# Database Environment\n")
		builder.WriteString("MYSQL_ROOT_PASSWORD=" + config.Database.RootPassword + "\n")
		builder.WriteString("MYSQL_DATABASE=" + config.Database.Database + "\n")
		builder.WriteString("MYSQL_USER=" + config.Database.User + "\n")
		builder.WriteString("MYSQL_PASSWORD=" + config.Database.Password + "\n")
	}

	// Write .env file
	if err := g.fs.WriteFile("deploy/compose/.env", builder.String(), 0644); err != nil {
		return fmt.Errorf("failed to write .env file: %w", err)
	}

	return nil
}

// findEggProjectRoot finds the root directory of the egg project.
//
// Parameters:
//   - None
//
// Returns:
//   - string: Path to egg project root
//   - error: Error if egg project root not found
//
// Concurrency:
//   - Single-threaded
//
// Performance:
//   - Directory traversal up to project root
func (g *BackendGenerator) findEggProjectRoot() (string, error) {
	currentDir := g.fs.GetRootDir()

	// Get absolute path
	absDir, err := filepath.Abs(currentDir)
	if err != nil {
		return "", fmt.Errorf("failed to get absolute path: %w", err)
	}
	currentDir = absDir

	if g.fs.GetVerbose() {
		ui.Debug("Searching for egg project root starting from: %s", currentDir)
	}

	// Look for go.work file which indicates the egg project root
	for {
		if g.fs.GetVerbose() {
			ui.Debug("Checking directory: %s", currentDir)
		}

		// Use os.Stat directly since we're checking absolute paths
		goWorkPath := filepath.Join(currentDir, "go.work")
		if _, err := os.Stat(goWorkPath); err == nil {
			if g.fs.GetVerbose() {
				ui.Debug("Found go.work at: %s", goWorkPath)
			}
			// Also check if this directory contains egg modules
			eggModules := []string{"core", "logx", "configx", "servicex", "cli"}
			hasEggModules := true
			for _, module := range eggModules {
				modulePath := filepath.Join(currentDir, module)
				if _, err := os.Stat(modulePath); err != nil {
					if g.fs.GetVerbose() {
						ui.Debug("Missing egg module: %s", modulePath)
					}
					hasEggModules = false
					break
				} else if g.fs.GetVerbose() {
					ui.Debug("Found egg module: %s", modulePath)
				}
			}
			if hasEggModules {
				if g.fs.GetVerbose() {
					ui.Debug("Found egg project root: %s", currentDir)
				}
				return currentDir, nil
			}
		}

		// Check if we've reached the filesystem root
		parent := filepath.Dir(currentDir)
		if parent == currentDir {
			if g.fs.GetVerbose() {
				ui.Debug("Reached filesystem root: %s", currentDir)
			}
			break
		}
		currentDir = parent
	}

	return "", fmt.Errorf("egg project root not found (looking for go.work file and egg modules)")
}

// Validation helper functions

func isValidServiceName(name string) bool {
	if name == "" || len(name) > 50 {
		return false
	}
	for _, r := range name {
		if !((r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') || r == '-' || r == '_') {
			return false
		}
	}
	return true
}

// dartifyServiceName converts a service name to a valid Dart package name.
// It replaces hyphens with underscores and ensures the name follows Dart naming conventions.
//
// Parameters:
//   - name: Service name to convert
//
// Returns:
//   - string: Valid Dart package name
//
// Concurrency:
//   - Safe for concurrent use
//
// Performance:
//   - O(n) string conversion
func dartifyServiceName(name string) string {
	return strings.ReplaceAll(name, "-", "_")
}

// isValidDartPackageName checks if a name is a valid Dart package name.
// Dart package names must:
// - Use only lowercase letters, numbers, and underscores
// - Not start with a number
// - Not be a reserved Dart keyword
//
// Parameters:
//   - name: Package name to validate
//
// Returns:
//   - bool: True if valid Dart package name
//
// Concurrency:
//   - Safe for concurrent use
//
// Performance:
//   - O(n) validation
func isValidDartPackageName(name string) bool {
	if name == "" || len(name) > 50 {
		return false
	}

	// Check if starts with a number
	if name[0] >= '0' && name[0] <= '9' {
		return false
	}

	// Check if all characters are valid
	for _, r := range name {
		if !((r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') || r == '_') {
			return false
		}
	}

	// Check for Dart reserved keywords
	dartReservedKeywords := []string{
		"abstract", "as", "assert", "async", "await", "break", "case", "catch",
		"class", "const", "continue", "covariant", "default", "deferred", "do",
		"dynamic", "else", "enum", "export", "extends", "extension", "external",
		"factory", "false", "final", "finally", "for", "function", "get", "hide",
		"if", "implements", "import", "in", "interface", "is", "late", "library",
		"mixin", "new", "null", "on", "operator", "part", "required", "rethrow",
		"return", "set", "show", "static", "super", "switch", "sync", "this",
		"throw", "true", "try", "typedef", "var", "void", "while", "with", "yield",
	}

	for _, keyword := range dartReservedKeywords {
		if name == keyword {
			return false
		}
	}

	return true
}

// camelCaseServiceName converts a service name to CamelCase for Go identifiers.
// It replaces hyphens and underscores with camelCase boundaries and capitalizes the first letter.
//
// Parameters:
//   - name: Service name to convert
//
// Returns:
//   - string: CamelCase service name
//
// Concurrency:
//   - Safe for concurrent use
//
// Performance:
//   - O(n) string conversion
func camelCaseServiceName(name string) string {
	if name == "" {
		return ""
	}

	parts := strings.FieldsFunc(name, func(r rune) bool {
		return r == '-' || r == '_'
	})

	if len(parts) == 0 {
		return ""
	}

	// Capitalize the first part
	result := strings.Title(strings.ToLower(parts[0]))
	for _, part := range parts[1:] {
		if part != "" {
			result += strings.Title(strings.ToLower(part))
		}
	}

	return result
}

// serviceNameToVar converts a service name to a valid Go variable name.
// It replaces hyphens and underscores with underscores and ensures the name is valid.
//
// Parameters:
//   - name: Service name to convert
//
// Returns:
//   - string: Valid Go variable name
//
// Concurrency:
//   - Safe for concurrent use
//
// Performance:
//   - O(n) string conversion
func serviceNameToVar(name string) string {
	if name == "" {
		return ""
	}

	// Replace hyphens and underscores with underscores
	result := strings.ReplaceAll(name, "-", "_")
	result = strings.ReplaceAll(result, "_", "_")

	// Ensure it starts with a letter
	if len(result) > 0 && (result[0] < 'a' || result[0] > 'z') {
		result = "service_" + result
	}

	return result
}

// prepareTemplateData prepares template data for rendering backend service templates.
//
// Parameters:
//   - name: Service name
//   - serviceConfig: Service configuration
//   - config: Project configuration
//
// Returns:
//   - *TemplateData: Prepared template data
//
// Concurrency:
//   - Safe for concurrent use
//
// Performance:
//   - O(1) data preparation
func (g *BackendGenerator) prepareTemplateData(name string, serviceConfig configschema.BackendService, config *configschema.Config, protoTemplate string) *TemplateData {
	// Get ports with defaults
	httpPort := 8080
	healthPort := 8081
	metricsPort := 9091

	if serviceConfig.Ports != nil {
		if serviceConfig.Ports.HTTP > 0 {
			httpPort = serviceConfig.Ports.HTTP
		}
		if serviceConfig.Ports.Health > 0 {
			healthPort = serviceConfig.Ports.Health
		}
		if serviceConfig.Ports.Metrics > 0 {
			metricsPort = serviceConfig.Ports.Metrics
		}
	}

	// Compute proto package from module prefix
	// e.g., "github.com/org/project" -> "org.project"
	protoPackage := computeProtoPackage(config.ModulePrefix)

	// Compute service module path
	// e.g., "github.com/org/project" + "user" -> "github.com/org/project/backend/user"
	serviceModulePath := config.ModulePrefix + "/backend/" + name

	return &TemplateData{
		ModulePrefix:      config.ModulePrefix,
		ServiceModulePath: serviceModulePath,
		ServiceName:       name,
		ServiceNameCamel:  camelCaseServiceName(name),
		ServiceNameVar:    serviceNameToVar(name),
		ProtoPackage:      protoPackage,
		BinaryName:        "server",
		HTTPPort:          httpPort,
		HealthPort:        healthPort,
		MetricsPort:       metricsPort,
		ProtoTemplate:     protoTemplate,
	}
}

// generateProtoFile generates a proto file for the service.
//
// Parameters:
//   - name: Service name
//   - protoTemplate: Proto template type (echo or crud)
//   - templateData: Template data for rendering
//
// Returns:
//   - error: Generation error if any
//
// Concurrency:
//   - Single-threaded
//
// Performance:
//   - Template rendering and file I/O
func (g *BackendGenerator) generateProtoFile(name string, protoTemplate string, templateData *TemplateData) error {
	ui.Info("Generating proto file: %s", protoTemplate)

	// Create API directory structure
	protoDir := filepath.Join("api", name, "v1")
	if err := g.fs.CreateDirectory(protoDir); err != nil {
		return fmt.Errorf("failed to create proto directory: %w", err)
	}

	// Convert TemplateData to map
	data := map[string]interface{}{
		"ModulePrefix":     templateData.ModulePrefix,
		"ServiceName":      templateData.ServiceName,
		"ServiceNameCamel": templateData.ServiceNameCamel,
		"ServiceNameVar":   templateData.ServiceNameVar,
		"ProtoPackage":     templateData.ProtoPackage,
	}

	// Load and render template
	var templatePath string
	if protoTemplate == "echo" {
		templatePath = "api/proto_echo.tmpl"
	} else if protoTemplate == "crud" {
		templatePath = "api/proto_crud.tmpl"
	} else {
		return fmt.Errorf("invalid proto template: %s", protoTemplate)
	}

	protoContent, err := g.loader.LoadAndRender(templatePath, data)
	if err != nil {
		return fmt.Errorf("failed to render proto template: %w", err)
	}

	// Write proto file
	protoFile := filepath.Join(protoDir, name+".proto")
	if err := g.fs.WriteFile(protoFile, protoContent, 0644); err != nil {
		return fmt.Errorf("failed to write proto file: %w", err)
	}

	ui.Success("Proto file generated: %s", protoFile)
	return nil
}

// Note: generateMakefile has been removed.
// Backend services are now built using egg CLI commands:
//   - egg build backend <service>  # Compile binary + build image
//   - egg build all                # Build all services
// No Makefiles are generated in new projects.

// computeProtoPackage computes the proto package name from module prefix.
// e.g., "github.com/org/project" -> "org.project"
//
// Parameters:
//   - modulePrefix: Go module prefix
//
// Returns:
//   - string: Proto package name
//
// Concurrency:
//   - Safe for concurrent use
//
// Performance:
//   - O(n) string processing
func computeProtoPackage(modulePrefix string) string {
	// Remove common prefixes
	modulePrefix = strings.TrimPrefix(modulePrefix, "github.com/")
	modulePrefix = strings.TrimPrefix(modulePrefix, "gitlab.com/")
	modulePrefix = strings.TrimPrefix(modulePrefix, "bitbucket.org/")

	// Replace slashes with dots
	protoPackage := strings.ReplaceAll(modulePrefix, "/", ".")

	// Replace hyphens with underscores (protobuf package names don't allow hyphens)
	protoPackage = strings.ReplaceAll(protoPackage, "-", "_")

	// Convert to lowercase
	protoPackage = strings.ToLower(protoPackage)

	return protoPackage
}
