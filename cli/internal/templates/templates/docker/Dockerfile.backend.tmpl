# ==============================================================================
# EggyByte Backend Service Image
# ==============================================================================
#
# Purpose:
#   Package a pre-compiled Go microservice binary into a minimal runtime container.
#   This Dockerfile is used by the egg CLI to create production-ready service images.
#
# Base Image:
#   ghcr.io/eggybyte-technology/eggybyte-go-alpine:go1.25.1-alpine3.22
#   (minimal Alpine runtime with CA certificates and timezone data)
#
# Build Process:
#   1. Compile binary using eggybyte-go-builder (done before docker build)
#   2. Run: egg build backend <service> (handles compilation + packaging)
#
# Build Args:
#   - SERVICE_NAME: Name of the service (e.g., "user", "order")
#   - BINARY_PATH: Path to pre-built binary (default: bin/backend/${SERVICE_NAME}/server)
#   - HTTP_PORT: Main HTTP service port (default: 8080)
#   - HEALTH_PORT: Health check endpoint port (default: 8081)
#   - METRICS_PORT: Prometheus metrics port (default: 9091)
#
# Runtime Environment:
#   - HTTP_PORT: Service listens on this port for requests
#   - HEALTH_PORT: Health check endpoint (GET /health)
#   - METRICS_PORT: Prometheus metrics endpoint (GET /metrics)
#
# Security:
#   - Runs as non-root user 'app' (inherited from base image)
#   - Static binary with no runtime dependencies
#   - Minimal attack surface (no shell, no package manager)
#
# Usage Example:
#   docker build -f docker/Dockerfile.backend \
#     --build-arg SERVICE_NAME=user \
#     --build-arg BINARY_PATH=bin/backend/user/server \
#     -t ghcr.io/myorg/myproject-user:v1.0.0 .
#
# ==============================================================================

FROM ghcr.io/eggybyte-technology/eggybyte-go-alpine:go1.25.1-alpine3.22

# Build-time arguments with defaults
ARG SERVICE_NAME="service"
ARG BINARY_PATH="bin/backend/${SERVICE_NAME}/server"
ARG HTTP_PORT=8080
ARG HEALTH_PORT=8081
ARG METRICS_PORT=9091

# Image metadata (populated by egg CLI at build time)
LABEL org.opencontainers.image.title="{{.ProjectName}}-${SERVICE_NAME}" \
      org.opencontainers.image.description="EggyByte microservice: ${SERVICE_NAME}" \
      org.opencontainers.image.source="{{.ModulePrefix}}" \
      org.opencontainers.image.vendor="EggyByte Technology" \
      org.opencontainers.image.licenses="MIT" \
      org.opencontainers.image.version="{{.Version}}"

# Set working directory (inherited from base, explicit for clarity)
WORKDIR /app

# Copy pre-built binary with execute permissions
# Binary must be compiled with CGO_ENABLED=0 for static linking
COPY --chmod=755 ${BINARY_PATH} /app/app

# Configure runtime environment variables
# Services should read these to determine which ports to bind
ENV HTTP_PORT=${HTTP_PORT} \
    HEALTH_PORT=${HEALTH_PORT} \
    METRICS_PORT=${METRICS_PORT}

# Expose service ports for documentation and inter-container communication
# Note: These don't actually publish ports; use -p flag at runtime
EXPOSE ${HTTP_PORT} ${HEALTH_PORT} ${METRICS_PORT}

# Run the service binary
# Inherits ENTRYPOINT ["/app/app"] from base image
# Override with CMD if service requires arguments

