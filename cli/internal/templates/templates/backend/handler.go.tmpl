// Package handler provides Connect protocol handlers for the {{.ServiceName}} service.
//
// Overview:
//   - Responsibility: Connect protocol implementation and request handling
//   - Key Types: {{.ServiceNameCamel}}Handler struct with Connect method implementations
//   - Concurrency Model: Thread-safe handlers with context propagation
//   - Error Semantics: Connect errors are properly mapped and returned
//   - Performance Notes: Optimized for high-throughput Connect requests
//
// Usage:
{{if .HasDatabase}}
//	handler := New{{.ServiceNameCamel}}Handler(service, logger)
{{else}}
//	handler := New{{.ServiceNameCamel}}Handler(logger)
{{end}}
//	connectHandler := {{.ServiceNameVar}}v1connect.New{{.ServiceNameCamel}}ServiceHandler(handler)
package handler

import (
	"context"
	"time"

	"connectrpc.com/connect"
	"go.eggybyte.com/egg/core/log"
	{{.ServiceNameVar}}v1 "{{.ModulePrefix}}/gen/go/{{.ServiceNameVar}}/v1"
	{{.ServiceNameVar}}v1connect "{{.ModulePrefix}}/gen/go/{{.ServiceNameVar}}/v1/{{.ServiceNameVar}}v1connect"
{{if .HasDatabase}}
	"{{.ServiceModulePath}}/internal/service"
{{end}}
)

// {{.ServiceNameCamel}}Handler implements the Connect protocol for the {{.ServiceName}} service.
// It bridges the Connect protocol with the business logic service.
type {{.ServiceNameCamel}}Handler struct {
	{{.ServiceNameVar}}v1connect.Unimplemented{{.ServiceNameCamel}}ServiceHandler

{{if .HasDatabase}}
	service service.{{.ServiceNameCamel}}Service
	logger  log.Logger
{{else}}
	logger log.Logger
{{end}}
}

// New{{.ServiceNameCamel}}Handler creates a new {{.ServiceNameCamel}}Handler instance.
// The returned handler is safe for concurrent use.
//
// Parameters:
{{if .HasDatabase}}
//   - service: {{.ServiceNameCamel}}Service implementation (must not be nil)
//   - logger: Logger instance (must not be nil)
{{else}}
//   - logger: Logger instance (must not be nil)
{{end}}
//
// Returns:
//   - *{{.ServiceNameCamel}}Handler: The created handler instance
//
// Panics:
{{if .HasDatabase}}
//   - If service is nil (fail-fast at startup)
//   - If logger is nil (fail-fast at startup)
{{else}}
//   - If logger is nil (fail-fast at startup)
{{end}}
//
// Rationale:
// This function panics on nil dependencies rather than returning an error
// because these are startup-time issues that should never occur in production.
// If dependencies are nil, the handler cannot function and should not start.
{{if .HasDatabase}}
func New{{.ServiceNameCamel}}Handler(service service.{{.ServiceNameCamel}}Service, logger log.Logger) *{{.ServiceNameCamel}}Handler {
	if service == nil {
		panic("New{{.ServiceNameCamel}}Handler: service cannot be nil")
	}
	if logger == nil {
		panic("New{{.ServiceNameCamel}}Handler: logger cannot be nil")
	}

	return &{{.ServiceNameCamel}}Handler{
		service: service,
		logger:  logger,
	}
}
{{else}}
func New{{.ServiceNameCamel}}Handler(logger log.Logger) *{{.ServiceNameCamel}}Handler {
	if logger == nil {
		panic("New{{.ServiceNameCamel}}Handler: logger cannot be nil")
	}

	return &{{.ServiceNameCamel}}Handler{
		logger: logger,
	}
}
{{end}}

{{if .HasDatabase}}
// Create{{.ServiceNameCamel}} handles Create{{.ServiceNameCamel}} Connect requests.
// It validates the request and delegates to the business service.
func (h *{{.ServiceNameCamel}}Handler) Create{{.ServiceNameCamel}}(ctx context.Context, req *connect.Request[{{.ServiceNameVar}}v1.Create{{.ServiceNameCamel}}Request]) (*connect.Response[{{.ServiceNameVar}}v1.Create{{.ServiceNameCamel}}Response], error) {
	// Only log at DEBUG level for intermediate steps - Connect interceptor handles request lifecycle
	h.logger.Debug("Create{{.ServiceNameCamel}} processing",
		log.Str("email", req.Msg.Email),
		log.Str("name", req.Msg.Name))

	// Delegate to business service
	response, err := h.service.Create{{.ServiceNameCamel}}(ctx, req.Msg)
	if err != nil {
		// Error logging is handled by Connect interceptor with proper error classification
		return nil, err
	}

	// Success logging is handled by Connect interceptor
	h.logger.Debug("Create{{.ServiceNameCamel}} completed",
		log.Str("{{.ServiceNameVar}}_id", response.{{.ServiceNameCamel}}.Id))

	return connect.NewResponse(response), nil
}

// Get{{.ServiceNameCamel}} handles Get{{.ServiceNameCamel}} Connect requests.
// It validates the request and delegates to the business service.
func (h *{{.ServiceNameCamel}}Handler) Get{{.ServiceNameCamel}}(ctx context.Context, req *connect.Request[{{.ServiceNameVar}}v1.Get{{.ServiceNameCamel}}Request]) (*connect.Response[{{.ServiceNameVar}}v1.Get{{.ServiceNameCamel}}Response], error) {
	// Only log at DEBUG level for intermediate steps - Connect interceptor handles request lifecycle
	h.logger.Debug("Get{{.ServiceNameCamel}} processing",
		log.Str("{{.ServiceNameVar}}_id", req.Msg.Id))

	// Delegate to business service
	response, err := h.service.Get{{.ServiceNameCamel}}(ctx, req.Msg)
	if err != nil {
		// Error logging is handled by Connect interceptor with proper error classification
		return nil, err
	}

	// Success logging is handled by Connect interceptor
	h.logger.Debug("Get{{.ServiceNameCamel}} completed",
		log.Str("{{.ServiceNameVar}}_id", response.{{.ServiceNameCamel}}.Id))

	return connect.NewResponse(response), nil
}

// Update{{.ServiceNameCamel}} handles Update{{.ServiceNameCamel}} Connect requests.
// It validates the request and delegates to the business service.
func (h *{{.ServiceNameCamel}}Handler) Update{{.ServiceNameCamel}}(ctx context.Context, req *connect.Request[{{.ServiceNameVar}}v1.Update{{.ServiceNameCamel}}Request]) (*connect.Response[{{.ServiceNameVar}}v1.Update{{.ServiceNameCamel}}Response], error) {
	// Only log at DEBUG level for intermediate steps - Connect interceptor handles request lifecycle
	h.logger.Debug("Update{{.ServiceNameCamel}} processing",
		log.Str("{{.ServiceNameVar}}_id", req.Msg.Id),
		log.Str("email", req.Msg.Email))

	// Delegate to business service
	response, err := h.service.Update{{.ServiceNameCamel}}(ctx, req.Msg)
	if err != nil {
		// Error logging is handled by Connect interceptor with proper error classification
		return nil, err
	}

	// Success logging is handled by Connect interceptor
	h.logger.Debug("Update{{.ServiceNameCamel}} completed",
		log.Str("{{.ServiceNameVar}}_id", response.{{.ServiceNameCamel}}.Id))

	return connect.NewResponse(response), nil
}

// Delete{{.ServiceNameCamel}} handles Delete{{.ServiceNameCamel}} Connect requests.
// It validates the request and delegates to the business service.
func (h *{{.ServiceNameCamel}}Handler) Delete{{.ServiceNameCamel}}(ctx context.Context, req *connect.Request[{{.ServiceNameVar}}v1.Delete{{.ServiceNameCamel}}Request]) (*connect.Response[{{.ServiceNameVar}}v1.Delete{{.ServiceNameCamel}}Response], error) {
	// Only log at DEBUG level for intermediate steps - Connect interceptor handles request lifecycle
	h.logger.Debug("Delete{{.ServiceNameCamel}} processing",
		log.Str("{{.ServiceNameVar}}_id", req.Msg.Id))

	// Delegate to business service
	response, err := h.service.Delete{{.ServiceNameCamel}}(ctx, req.Msg)
	if err != nil {
		// Error logging is handled by Connect interceptor with proper error classification
		return nil, err
	}

	// Success logging is handled by Connect interceptor
	h.logger.Debug("Delete{{.ServiceNameCamel}} completed",
		log.Str("{{.ServiceNameVar}}_id", req.Msg.Id))

	return connect.NewResponse(response), nil
}

// List{{.ServiceNameCamel}}s handles List{{.ServiceNameCamel}}s Connect requests.
// It validates the request and delegates to the business service.
func (h *{{.ServiceNameCamel}}Handler) List{{.ServiceNameCamel}}s(ctx context.Context, req *connect.Request[{{.ServiceNameVar}}v1.List{{.ServiceNameCamel}}sRequest]) (*connect.Response[{{.ServiceNameVar}}v1.List{{.ServiceNameCamel}}sResponse], error) {
	// Only log at DEBUG level for intermediate steps - Connect interceptor handles request lifecycle
	h.logger.Debug("List{{.ServiceNameCamel}}s processing",
		log.Int("page", int(req.Msg.Page)),
		log.Int("page_size", int(req.Msg.PageSize)))

	// Delegate to business service
	response, err := h.service.List{{.ServiceNameCamel}}s(ctx, req.Msg)
	if err != nil {
		// Error logging is handled by Connect interceptor with proper error classification
		return nil, err
	}

	// Success logging is handled by Connect interceptor
	h.logger.Debug("List{{.ServiceNameCamel}}s completed",
		log.Int("count", len(response.{{.ServiceNameCamel}}s)),
		log.Int("total", int(response.Total)))

	return connect.NewResponse(response), nil
}
{{else}}
// Ping handles Ping Connect requests.
// It responds with the service name and current timestamp.
func (h *{{.ServiceNameCamel}}Handler) Ping(ctx context.Context, req *connect.Request[{{.ServiceNameVar}}v1.PingRequest]) (*connect.Response[{{.ServiceNameVar}}v1.PingResponse], error) {
	h.logger.Debug("Ping processing",
		log.Str("message", req.Msg.Message))

	// Echo the message and return service info
	response := &{{.ServiceNameVar}}v1.PingResponse{
		Message:  req.Msg.Message,
		Service:   "{{.ServiceNameVar}}",
		TsUnix:   time.Now().Unix(),
	}

	h.logger.Debug("Ping completed",
		log.Str("service", response.Service),
		log.Int64("ts_unix", response.TsUnix))

	return connect.NewResponse(response), nil
}
{{end}}
