// Package service provides business logic for the {{.ServiceName}} service.
//
// Overview:
//   - Responsibility: Business logic and domain operations
//   - Key Types: {{.ServiceNameCamel}}Service interface and implementation
//   - Concurrency Model: Thread-safe service operations
//   - Error Semantics: Domain errors are wrapped and returned
//   - Performance Notes: Optimized for high-throughput operations
//
// Usage:
//
//	service := New{{.ServiceNameCamel}}Service(repo)
//	{{.ServiceNameVar}}, err := service.Create{{.ServiceNameCamel}}(ctx, &Create{{.ServiceNameCamel}}Request{Name: "example"})
package service

import (
	"context"

	"github.com/eggybyte-technology/egg/core/errors"
	"github.com/eggybyte-technology/egg/core/log"
	{{.ServiceNameCamel}}v1 "{{.ModulePrefix}}/backend/{{.ServiceName}}/gen/go/{{.ServiceName}}/v1"
	"{{.ModulePrefix}}/backend/{{.ServiceName}}/internal/model"
	"{{.ModulePrefix}}/backend/{{.ServiceName}}/internal/repository"
)

// {{.ServiceNameCamel}}Service defines the interface for {{.ServiceName}} business operations.
// All methods are context-aware and return structured errors.
type {{.ServiceNameCamel}}Service interface {
	// Create{{.ServiceNameCamel}} creates a new {{.ServiceName}} with business validation.
	Create{{.ServiceNameCamel}}(ctx context.Context, req *{{.ServiceNameCamel}}v1.Create{{.ServiceNameCamel}}Request) (*{{.ServiceNameCamel}}v1.Create{{.ServiceNameCamel}}Response, error)

	// Get{{.ServiceNameCamel}} retrieves a {{.ServiceName}} by ID with proper error handling.
	Get{{.ServiceNameCamel}}(ctx context.Context, req *{{.ServiceNameCamel}}v1.Get{{.ServiceNameCamel}}Request) (*{{.ServiceNameCamel}}v1.Get{{.ServiceNameCamel}}Response, error)

	// Update{{.ServiceNameCamel}} updates an existing {{.ServiceName}} with validation.
	Update{{.ServiceNameCamel}}(ctx context.Context, req *{{.ServiceNameCamel}}v1.Update{{.ServiceNameCamel}}Request) (*{{.ServiceNameCamel}}v1.Update{{.ServiceNameCamel}}Response, error)

	// Delete{{.ServiceNameCamel}} removes a {{.ServiceName}} by ID.
	Delete{{.ServiceNameCamel}}(ctx context.Context, req *{{.ServiceNameCamel}}v1.Delete{{.ServiceNameCamel}}Request) (*{{.ServiceNameCamel}}v1.Delete{{.ServiceNameCamel}}Response, error)

	// List{{.ServiceNameCamel}}s retrieves {{.ServiceName}}s with pagination.
	List{{.ServiceNameCamel}}s(ctx context.Context, req *{{.ServiceNameCamel}}v1.List{{.ServiceNameCamel}}sRequest) (*{{.ServiceNameCamel}}v1.List{{.ServiceNameCamel}}sResponse, error)
}

// {{.ServiceNameCamel}}Service implements the {{.ServiceNameCamel}}Service interface.
type {{.ServiceNameCamel}}Service struct {
	repo   repository.{{.ServiceNameCamel}}Repository
	logger log.Logger
}

// New{{.ServiceNameCamel}}Service creates a new {{.ServiceNameCamel}}Service instance.
// The returned service is safe for concurrent use.
//
// Parameters:
//   - repo: {{.ServiceNameCamel}}Repository implementation (must not be nil)
//   - logger: Logger instance (must not be nil)
//
// Returns:
//   - {{.ServiceNameCamel}}Service: The created service instance
//
// Panics:
//   - If repo is nil (fail-fast at startup)
//   - If logger is nil (fail-fast at startup)
//
// Rationale:
// This function panics on nil dependencies rather than returning an error
// because these are startup-time issues that should never occur in production.
// If dependencies are nil, the service cannot function and should not start.
func New{{.ServiceNameCamel}}Service(repo repository.{{.ServiceNameCamel}}Repository, logger log.Logger) {{.ServiceNameCamel}}Service {
	if repo == nil {
		panic("New{{.ServiceNameCamel}}Service: repository cannot be nil")
	}
	if logger == nil {
		panic("New{{.ServiceNameCamel}}Service: logger cannot be nil")
	}
	
	return &{{.ServiceNameCamel}}Service{
		repo:   repo,
		logger: logger,
	}
}

// Create{{.ServiceNameCamel}} creates a new {{.ServiceName}} with business validation.
func (s *{{.ServiceNameCamel}}Service) Create{{.ServiceNameCamel}}(ctx context.Context, req *{{.ServiceNameCamel}}v1.Create{{.ServiceNameCamel}}Request) (*{{.ServiceNameCamel}}v1.Create{{.ServiceNameCamel}}Response, error) {
	// Validate request
	if req.Name == "" {
		return nil, errors.New(errors.CodeInvalidArgument, "name is required")
	}

	// Create {{.ServiceName}} model
	{{.ServiceNameVar}} := &model.{{.ServiceNameCamel}}{
		Name: req.Name,
	}

	// Create {{.ServiceName}} in repository
	created{{.ServiceNameCamel}}, err := s.repo.Create(ctx, {{.ServiceNameVar}})
	if err != nil {
		// Error logging is handled by Connect interceptor with proper error classification
		// Only log at DEBUG level here for debugging purposes
		s.logger.Debug("Create {{.ServiceName}} failed", log.Str("name", req.Name), log.Str("error", err.Error()))
		return nil, err
	}

	// Success logging is handled by Connect interceptor - no need to log here
	s.logger.Debug("{{.ServiceNameCamel}} created in repository",
		log.Str("{{.ServiceName}}_id", created{{.ServiceNameCamel}}.ID),
		log.Str("name", created{{.ServiceNameCamel}}.Name))

	// Convert to response
	response := &{{.ServiceNameCamel}}v1.Create{{.ServiceNameCamel}}Response{
		{{.ServiceNameCamel}}: &{{.ServiceNameCamel}}v1.{{.ServiceNameCamel}}{
			Id:        created{{.ServiceNameCamel}}.ID,
			Name:      created{{.ServiceNameCamel}}.Name,
			CreatedAt: created{{.ServiceNameCamel}}.CreatedAt.Unix(),
			UpdatedAt: created{{.ServiceNameCamel}}.UpdatedAt.Unix(),
		},
	}

	return response, nil
}

// Get{{.ServiceNameCamel}} retrieves a {{.ServiceName}} by ID with proper error handling.
func (s *{{.ServiceNameCamel}}Service) Get{{.ServiceNameCamel}}(ctx context.Context, req *{{.ServiceNameCamel}}v1.Get{{.ServiceNameCamel}}Request) (*{{.ServiceNameCamel}}v1.Get{{.ServiceNameCamel}}Response, error) {
	// Validate request
	if req.Id == "" {
		return nil, errors.New(errors.CodeInvalidArgument, "{{.ServiceName}} ID is required")
	}

	// Get {{.ServiceName}} from repository
	{{.ServiceNameVar}}, err := s.repo.GetByID(ctx, req.Id)
	if err != nil {
		// Error logging is handled by Connect interceptor with proper error classification
		s.logger.Debug("Get {{.ServiceName}} failed", log.Str("{{.ServiceName}}_id", req.Id), log.Str("error", err.Error()))
		return nil, err
	}

	// Success logging is handled by Connect interceptor - no need to log here
	s.logger.Debug("{{.ServiceNameCamel}} retrieved from repository", log.Str("{{.ServiceName}}_id", {{.ServiceNameVar}}.ID))

	// Convert to response
	response := &{{.ServiceNameCamel}}v1.Get{{.ServiceNameCamel}}Response{
		{{.ServiceNameCamel}}: &{{.ServiceNameCamel}}v1.{{.ServiceNameCamel}}{
			Id:        {{.ServiceNameVar}}.ID,
			Name:      {{.ServiceNameVar}}.Name,
			CreatedAt: {{.ServiceNameVar}}.CreatedAt.Unix(),
			UpdatedAt: {{.ServiceNameVar}}.UpdatedAt.Unix(),
		},
	}

	return response, nil
}

// Update{{.ServiceNameCamel}} updates an existing {{.ServiceName}} with validation.
func (s *{{.ServiceNameCamel}}Service) Update{{.ServiceNameCamel}}(ctx context.Context, req *{{.ServiceNameCamel}}v1.Update{{.ServiceNameCamel}}Request) (*{{.ServiceNameCamel}}v1.Update{{.ServiceNameCamel}}Response, error) {
	// Validate request
	if req.Id == "" {
		return nil, errors.New(errors.CodeInvalidArgument, "{{.ServiceName}} ID is required")
	}
	if req.Name == "" {
		return nil, errors.New(errors.CodeInvalidArgument, "name is required")
	}

	// Create {{.ServiceName}} model
	{{.ServiceNameVar}} := &model.{{.ServiceNameCamel}}{
		ID:   req.Id,
		Name: req.Name,
	}

	// Update {{.ServiceName}} in repository
	updated{{.ServiceNameCamel}}, err := s.repo.Update(ctx, {{.ServiceNameVar}})
	if err != nil {
		// Error logging is handled by Connect interceptor with proper error classification
		s.logger.Debug("Update {{.ServiceName}} failed", log.Str("{{.ServiceName}}_id", req.Id), log.Str("error", err.Error()))
		return nil, err
	}

	// Success logging is handled by Connect interceptor - no need to log here
	s.logger.Debug("{{.ServiceNameCamel}} updated in repository",
		log.Str("{{.ServiceName}}_id", updated{{.ServiceNameCamel}}.ID),
		log.Str("name", updated{{.ServiceNameCamel}}.Name))

	// Convert to response
	response := &{{.ServiceNameCamel}}v1.Update{{.ServiceNameCamel}}Response{
		{{.ServiceNameCamel}}: &{{.ServiceNameCamel}}v1.{{.ServiceNameCamel}}{
			Id:        updated{{.ServiceNameCamel}}.ID,
			Name:      updated{{.ServiceNameCamel}}.Name,
			CreatedAt: updated{{.ServiceNameCamel}}.CreatedAt.Unix(),
			UpdatedAt: updated{{.ServiceNameCamel}}.UpdatedAt.Unix(),
		},
	}

	return response, nil
}

// Delete{{.ServiceNameCamel}} removes a {{.ServiceName}} by ID.
func (s *{{.ServiceNameCamel}}Service) Delete{{.ServiceNameCamel}}(ctx context.Context, req *{{.ServiceNameCamel}}v1.Delete{{.ServiceNameCamel}}Request) (*{{.ServiceNameCamel}}v1.Delete{{.ServiceNameCamel}}Response, error) {
	// Validate request
	if req.Id == "" {
		return nil, errors.New(errors.CodeInvalidArgument, "{{.ServiceName}} ID is required")
	}

	// Delete {{.ServiceName}} from repository
	err := s.repo.Delete(ctx, req.Id)
	if err != nil {
		// Error logging is handled by Connect interceptor with proper error classification
		s.logger.Debug("Delete {{.ServiceName}} failed", log.Str("{{.ServiceName}}_id", req.Id), log.Str("error", err.Error()))
		return nil, err
	}

	// Success logging is handled by Connect interceptor - no need to log here
	s.logger.Debug("{{.ServiceNameCamel}} deleted from repository", log.Str("{{.ServiceName}}_id", req.Id))

	// Convert to response
	response := &{{.ServiceNameCamel}}v1.Delete{{.ServiceNameCamel}}Response{
		Success: true,
	}

	return response, nil
}

// List{{.ServiceNameCamel}}s retrieves {{.ServiceName}}s with pagination.
func (s *{{.ServiceNameCamel}}Service) List{{.ServiceNameCamel}}s(ctx context.Context, req *{{.ServiceNameCamel}}v1.List{{.ServiceNameCamel}}sRequest) (*{{.ServiceNameCamel}}v1.List{{.ServiceNameCamel}}sResponse, error) {
	// Set default pagination
	page := int(req.Page)
	if page < 1 {
		page = 1
	}

	pageSize := int(req.PageSize)
	if pageSize < 1 || pageSize > 100 {
		pageSize = 10
	}

	// Get {{.ServiceName}}s from repository
	{{.ServiceNameVar}}s, total, err := s.repo.List(ctx, page, pageSize)
	if err != nil {
		// Error logging is handled by Connect interceptor with proper error classification
		s.logger.Debug("List {{.ServiceName}}s failed",
			log.Int("page", page),
			log.Int("page_size", pageSize),
			log.Str("error", err.Error()))
		return nil, err
	}

	// Success logging is handled by Connect interceptor - no need to log here
	s.logger.Debug("{{.ServiceNameCamel}}s listed from repository",
		log.Int("count", len({{.ServiceNameVar}}s)),
		log.Int("total", int(total)),
		log.Int("page", page))

	// Convert to response
	response{{.ServiceNameCamel}}s := make([]*{{.ServiceNameCamel}}v1.{{.ServiceNameCamel}}, len({{.ServiceNameVar}}s))
	for i, {{.ServiceNameVar}} := range {{.ServiceNameVar}}s {
		response{{.ServiceNameCamel}}s[i] = &{{.ServiceNameCamel}}v1.{{.ServiceNameCamel}}{
			Id:        {{.ServiceNameVar}}.ID,
			Name:      {{.ServiceNameVar}}.Name,
			CreatedAt: {{.ServiceNameVar}}.CreatedAt.Unix(),
			UpdatedAt: {{.ServiceNameVar}}.UpdatedAt.Unix(),
		}
	}

	response := &{{.ServiceNameCamel}}v1.List{{.ServiceNameCamel}}sResponse{
		{{.ServiceNameCamel}}s: response{{.ServiceNameCamel}}s,
		Total:    int32(total),
		Page:     int32(page),
		PageSize: int32(pageSize),
	}

	return response, nil
}
