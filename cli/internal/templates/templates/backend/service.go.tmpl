// Package service provides business logic for the {{.ServiceName}} service.
//
// Overview:
//   - Responsibility: Business logic and domain operations
//   - Key Types: {{.ServiceNameCamel}}Service interface and implementation
//   - Concurrency Model: Thread-safe service operations
//   - Error Semantics: Domain errors are wrapped and returned
//   - Performance Notes: Optimized for high-throughput operations
//
// Usage:
//
//	service := New{{.ServiceNameCamel}}Service(repo, logger)
//	{{.ServiceNameVar}}, err := service.Create{{.ServiceNameCamel}}(ctx, &Create{{.ServiceNameCamel}}Request{Email: "{{.ServiceNameVar}}@example.com"})
package service

import (
	"context"

	"go.eggybyte.com/egg/core/errors"
	"go.eggybyte.com/egg/core/log"
	{{.ServiceNameVar}}v1 "{{.ModulePrefix}}/gen/go/{{.ServiceNameVar}}/v1"
	"{{.ServiceModulePath}}/internal/model"
	"{{.ServiceModulePath}}/internal/repository"
)

// {{.ServiceNameCamel}}Service defines the interface for {{.ServiceName}} business operations.
// All methods are context-aware and return structured errors.
type {{.ServiceNameCamel}}Service interface {
	// Create{{.ServiceNameCamel}} creates a new {{.ServiceName}} with business validation.
	Create{{.ServiceNameCamel}}(ctx context.Context, req *{{.ServiceNameVar}}v1.Create{{.ServiceNameCamel}}Request) (*{{.ServiceNameVar}}v1.Create{{.ServiceNameCamel}}Response, error)

	// Get{{.ServiceNameCamel}} retrieves a {{.ServiceName}} by ID with proper error handling.
	Get{{.ServiceNameCamel}}(ctx context.Context, req *{{.ServiceNameVar}}v1.Get{{.ServiceNameCamel}}Request) (*{{.ServiceNameVar}}v1.Get{{.ServiceNameCamel}}Response, error)

	// Update{{.ServiceNameCamel}} updates an existing {{.ServiceName}} with validation.
	Update{{.ServiceNameCamel}}(ctx context.Context, req *{{.ServiceNameVar}}v1.Update{{.ServiceNameCamel}}Request) (*{{.ServiceNameVar}}v1.Update{{.ServiceNameCamel}}Response, error)

	// Delete{{.ServiceNameCamel}} removes a {{.ServiceName}} by ID.
	Delete{{.ServiceNameCamel}}(ctx context.Context, req *{{.ServiceNameVar}}v1.Delete{{.ServiceNameCamel}}Request) (*{{.ServiceNameVar}}v1.Delete{{.ServiceNameCamel}}Response, error)

	// List{{.ServiceNameCamel}}s retrieves {{.ServiceName}}s with pagination.
	List{{.ServiceNameCamel}}s(ctx context.Context, req *{{.ServiceNameVar}}v1.List{{.ServiceNameCamel}}sRequest) (*{{.ServiceNameVar}}v1.List{{.ServiceNameCamel}}sResponse, error)
}

// {{.ServiceNameVar | ToLower}}Service implements the {{.ServiceNameCamel}}Service interface.
type {{.ServiceNameVar | ToLower}}Service struct {
	repo   repository.{{.ServiceNameCamel}}Repository
	logger log.Logger
}

// New{{.ServiceNameCamel}}Service creates a new {{.ServiceNameCamel}}Service instance with dependency injection.
//
// This constructor demonstrates the egg framework's dependency injection pattern:
// accepting interfaces (not concrete types) to enable testability and flexibility.
//
// Parameters:
//   - repo: {{.ServiceNameCamel}}Repository implementation for data access (must not be nil)
//   - logger: Logger implementation for structured logging (must not be nil)
//
// Returns:
//   - {{.ServiceNameCamel}}Service: service instance ready for use
//
// Panics:
//   - If repo is nil (fail-fast at startup)
//   - If logger is nil (fail-fast at startup)
//
// Rationale:
//
// This function panics on nil dependencies rather than returning an error because
// these are startup-time configuration issues that should never occur in production.
// Panicking during initialization is preferable to runtime nil pointer dereferences.
//
// Concurrency:
//
//	Returned service is safe for concurrent use across multiple goroutines.
func New{{.ServiceNameCamel}}Service(repo repository.{{.ServiceNameCamel}}Repository, logger log.Logger) {{.ServiceNameCamel}}Service {
	if repo == nil {
		panic("New{{.ServiceNameCamel}}Service: repository cannot be nil")
	}
	if logger == nil {
		panic("New{{.ServiceNameCamel}}Service: logger cannot be nil")
	}

	return &{{.ServiceNameVar | ToLower}}Service{
		repo:   repo,
		logger: logger,
	}
}

// Create{{.ServiceNameCamel}} creates a new {{.ServiceName}} with comprehensive business validation.
//
// This method implements multi-layer validation:
//  1. Request field validation (required fields)
//  2. Domain model validation (format, constraints)
//  3. Business rule validation (uniqueness via repository)
//
// Parameters:
//   - ctx: request context for cancellation and deadlines
//   - req: protobuf request containing email and name
//
// Returns:
//   - *{{.ServiceNameVar}}v1.Create{{.ServiceNameCamel}}Response: response with created {{.ServiceName}} details
//   - error: nil on success; structured error on failure
//   - CodeInvalidArgument: validation failed (empty/invalid fields)
//   - CodeAlreadyExists: email already registered
//   - CodeInternal: database operation failed
//
// Behavior:
//   - Generates UUID for new {{.ServiceName}} automatically
//   - Sets created_at and updated_at timestamps
//   - Logs validation and operation steps at DEBUG level
//
// Concurrency:
//
//	Safe for concurrent use. Database handles race conditions with unique constraints.
func (s *{{.ServiceNameVar | ToLower}}Service) Create{{.ServiceNameCamel}}(ctx context.Context, req *{{.ServiceNameVar}}v1.Create{{.ServiceNameCamel}}Request) (*{{.ServiceNameVar}}v1.Create{{.ServiceNameCamel}}Response, error) {
	s.logger.Debug("Create{{.ServiceNameCamel}} started", log.Str("email", req.Email), log.Str("name", req.Name))

	// Validate request fields
	if req.Email == "" {
		s.logger.Debug("Create{{.ServiceNameCamel}} validation failed: empty email")
		return nil, errors.New(errors.CodeInvalidArgument, "email is required")
	}
	if req.Name == "" {
		s.logger.Debug("Create{{.ServiceNameCamel}} validation failed: empty name")
		return nil, errors.New(errors.CodeInvalidArgument, "name is required")
	}

	// Create and validate {{.ServiceName}} model
	{{.ServiceNameVar}} := &model.{{.ServiceNameCamel}}{
		Email: req.Email,
		Name:  req.Name,
	}

	if err := {{.ServiceNameVar}}.Validate(); err != nil {
		s.logger.Debug("Create{{.ServiceNameCamel}} model validation failed", log.Str("email", req.Email), log.Str("error", err.Error()))
		return nil, err
	}

	s.logger.Debug("Create{{.ServiceNameCamel}} calling repository", log.Str("email", req.Email))

	// Create {{.ServiceName}} in repository
	created{{.ServiceNameCamel}}, err := s.repo.Create(ctx, {{.ServiceNameVar}})
	if err != nil {
		s.logger.Debug("Create{{.ServiceNameCamel}} repository failed", log.Str("email", req.Email), log.Str("error", err.Error()))
		return nil, err
	}

	s.logger.Debug("Create{{.ServiceNameCamel}} completed successfully",
		log.Str("{{.ServiceNameVar}}_id", created{{.ServiceNameCamel}}.ID),
		log.Str("email", created{{.ServiceNameCamel}}.Email))

	return &{{.ServiceNameVar}}v1.Create{{.ServiceNameCamel}}Response{
		{{.ServiceNameCamel}}: toProto{{.ServiceNameCamel}}(created{{.ServiceNameCamel}}),
	}, nil
}

// Get{{.ServiceNameCamel}} retrieves a {{.ServiceName}} by ID with proper error handling.
func (s *{{.ServiceNameVar | ToLower}}Service) Get{{.ServiceNameCamel}}(ctx context.Context, req *{{.ServiceNameVar}}v1.Get{{.ServiceNameCamel}}Request) (*{{.ServiceNameVar}}v1.Get{{.ServiceNameCamel}}Response, error) {
	s.logger.Debug("Get{{.ServiceNameCamel}} started", log.Str("{{.ServiceNameVar}}_id", req.Id))

	if req.Id == "" {
		s.logger.Debug("Get{{.ServiceNameCamel}} validation failed: empty ID")
		return nil, errors.New(errors.CodeInvalidArgument, "{{.ServiceName}} ID is required")
	}

	s.logger.Debug("Get{{.ServiceNameCamel}} calling repository", log.Str("{{.ServiceNameVar}}_id", req.Id))

	{{.ServiceNameVar}}, err := s.repo.GetByID(ctx, req.Id)
	if err != nil {
		s.logger.Debug("Get{{.ServiceNameCamel}} repository failed", log.Str("{{.ServiceNameVar}}_id", req.Id), log.Str("error", err.Error()))
		return nil, err
	}

	s.logger.Debug("Get{{.ServiceNameCamel}} completed successfully",
		log.Str("{{.ServiceNameVar}}_id", {{.ServiceNameVar}}.ID),
		log.Str("email", {{.ServiceNameVar}}.Email))

	return &{{.ServiceNameVar}}v1.Get{{.ServiceNameCamel}}Response{
		{{.ServiceNameCamel}}: toProto{{.ServiceNameCamel}}({{.ServiceNameVar}}),
	}, nil
}

// Update{{.ServiceNameCamel}} updates an existing {{.ServiceName}} with validation.
func (s *{{.ServiceNameVar | ToLower}}Service) Update{{.ServiceNameCamel}}(ctx context.Context, req *{{.ServiceNameVar}}v1.Update{{.ServiceNameCamel}}Request) (*{{.ServiceNameVar}}v1.Update{{.ServiceNameCamel}}Response, error) {
	s.logger.Debug("Update{{.ServiceNameCamel}} started",
		log.Str("{{.ServiceNameVar}}_id", req.Id),
		log.Str("email", req.Email),
		log.Str("name", req.Name))

	// Validate request fields
	if req.Id == "" {
		s.logger.Debug("Update{{.ServiceNameCamel}} validation failed: empty ID")
		return nil, errors.New(errors.CodeInvalidArgument, "{{.ServiceName}} ID is required")
	}
	if req.Email == "" {
		s.logger.Debug("Update{{.ServiceNameCamel}} validation failed: empty email")
		return nil, errors.New(errors.CodeInvalidArgument, "email is required")
	}
	if req.Name == "" {
		s.logger.Debug("Update{{.ServiceNameCamel}} validation failed: empty name")
		return nil, errors.New(errors.CodeInvalidArgument, "name is required")
	}

	s.logger.Debug("Update{{.ServiceNameCamel}} fetching existing {{.ServiceName}}", log.Str("{{.ServiceNameVar}}_id", req.Id))

	// Get existing {{.ServiceName}} to preserve timestamps
	existing{{.ServiceNameCamel}}, err := s.repo.GetByID(ctx, req.Id)
	if err != nil {
		s.logger.Debug("Update{{.ServiceNameCamel}} get existing {{.ServiceName}} failed", log.Str("{{.ServiceNameVar}}_id", req.Id), log.Str("error", err.Error()))
		return nil, err
	}

	// Build updated {{.ServiceName}} model
	{{.ServiceNameVar}} := &model.{{.ServiceNameCamel}}{
		ID:        req.Id,
		Email:     req.Email,
		Name:      req.Name,
		CreatedAt: existing{{.ServiceNameCamel}}.CreatedAt,
	}

	if err := {{.ServiceNameVar}}.Validate(); err != nil {
		s.logger.Debug("Update{{.ServiceNameCamel}} model validation failed", log.Str("{{.ServiceNameVar}}_id", req.Id), log.Str("error", err.Error()))
		return nil, err
	}

	s.logger.Debug("Update{{.ServiceNameCamel}} calling repository", log.Str("{{.ServiceNameVar}}_id", req.Id))

	updated{{.ServiceNameCamel}}, err := s.repo.Update(ctx, {{.ServiceNameVar}})
	if err != nil {
		s.logger.Debug("Update{{.ServiceNameCamel}} repository failed", log.Str("{{.ServiceNameVar}}_id", req.Id), log.Str("error", err.Error()))
		return nil, err
	}

	s.logger.Debug("Update{{.ServiceNameCamel}} completed successfully",
		log.Str("{{.ServiceNameVar}}_id", updated{{.ServiceNameCamel}}.ID),
		log.Str("email", updated{{.ServiceNameCamel}}.Email))

	return &{{.ServiceNameVar}}v1.Update{{.ServiceNameCamel}}Response{
		{{.ServiceNameCamel}}: toProto{{.ServiceNameCamel}}(updated{{.ServiceNameCamel}}),
	}, nil
}

// Delete{{.ServiceNameCamel}} removes a {{.ServiceName}} by ID.
func (s *{{.ServiceNameVar | ToLower}}Service) Delete{{.ServiceNameCamel}}(ctx context.Context, req *{{.ServiceNameVar}}v1.Delete{{.ServiceNameCamel}}Request) (*{{.ServiceNameVar}}v1.Delete{{.ServiceNameCamel}}Response, error) {
	s.logger.Debug("Delete{{.ServiceNameCamel}} started", log.Str("{{.ServiceNameVar}}_id", req.Id))

	if req.Id == "" {
		s.logger.Debug("Delete{{.ServiceNameCamel}} validation failed: empty ID")
		return nil, errors.New(errors.CodeInvalidArgument, "{{.ServiceName}} ID is required")
	}

	s.logger.Debug("Delete{{.ServiceNameCamel}} calling repository", log.Str("{{.ServiceNameVar}}_id", req.Id))

	if err := s.repo.Delete(ctx, req.Id); err != nil {
		s.logger.Debug("Delete{{.ServiceNameCamel}} repository failed", log.Str("{{.ServiceNameVar}}_id", req.Id), log.Str("error", err.Error()))
		return nil, err
	}

	s.logger.Debug("Delete{{.ServiceNameCamel}} completed successfully", log.Str("{{.ServiceNameVar}}_id", req.Id))

	return &{{.ServiceNameVar}}v1.Delete{{.ServiceNameCamel}}Response{
		Success: true,
	}, nil
}

// List{{.ServiceNameCamel}}s retrieves {{.ServiceName}}s with pagination.
func (s *{{.ServiceNameVar | ToLower}}Service) List{{.ServiceNameCamel}}s(ctx context.Context, req *{{.ServiceNameVar}}v1.List{{.ServiceNameCamel}}sRequest) (*{{.ServiceNameVar}}v1.List{{.ServiceNameCamel}}sResponse, error) {
	// Normalize pagination parameters
	page := normalizePage(int(req.Page))
	pageSize := normalizePageSize(int(req.PageSize))

	s.logger.Debug("List{{.ServiceNameCamel}}s started",
		log.Int("requested_page", int(req.Page)),
		log.Int("requested_page_size", int(req.PageSize)),
		log.Int("normalized_page", page),
		log.Int("normalized_page_size", pageSize))

	s.logger.Debug("List{{.ServiceNameCamel}}s calling repository",
		log.Int("page", page),
		log.Int("page_size", pageSize))

	{{.ServiceNameVar}}s, total, err := s.repo.List(ctx, page, pageSize)
	if err != nil {
		s.logger.Debug("List{{.ServiceNameCamel}}s repository failed",
			log.Int("page", page),
			log.Int("page_size", pageSize),
			log.Str("error", err.Error()))
		return nil, err
	}

	s.logger.Debug("List{{.ServiceNameCamel}}s completed successfully",
		log.Int("returned_count", len({{.ServiceNameVar}}s)),
		log.Int("total", int(total)),
		log.Int("page", page),
		log.Int("page_size", pageSize))

	// Convert {{.ServiceName}}s to proto
	proto{{.ServiceNameCamel}}s := make([]*{{.ServiceNameVar}}v1.{{.ServiceNameCamel}}, len({{.ServiceNameVar}}s))
	for i, {{.ServiceNameVar}} := range {{.ServiceNameVar}}s {
		proto{{.ServiceNameCamel}}s[i] = toProto{{.ServiceNameCamel}}({{.ServiceNameVar}})
	}

	return &{{.ServiceNameVar}}v1.List{{.ServiceNameCamel}}sResponse{
		{{.ServiceNameCamel}}s: proto{{.ServiceNameCamel}}s,
		Total:                   int32(total),
		Page:                    int32(page),
		PageSize:                int32(pageSize),
	}, nil
}

// toProto{{.ServiceNameCamel}} converts a domain {{.ServiceNameCamel}} model to protobuf {{.ServiceNameCamel}} message.
//
// This helper function eliminates code duplication across service methods and
// centralizes the mapping logic between domain and API layers.
//
// Parameters:
//   - {{.ServiceNameVar}}: domain {{.ServiceName}} model (must not be nil)
//
// Returns:
//   - *{{.ServiceNameVar}}v1.{{.ServiceNameCamel}}: protobuf {{.ServiceName}} message with Unix timestamps
//
// Behavior:
//   - Timestamps are converted from time.Time to Unix epoch seconds
//   - All string fields are copied directly
//   - No validation is performed (assumes valid domain model)
//
// Concurrency:
//
//	Safe for concurrent use (pure function, no shared state).
func toProto{{.ServiceNameCamel}}({{.ServiceNameVar}} *model.{{.ServiceNameCamel}}) *{{.ServiceNameVar}}v1.{{.ServiceNameCamel}} {
	return &{{.ServiceNameVar}}v1.{{.ServiceNameCamel}}{
		Id:        {{.ServiceNameVar}}.ID,
		Email:     {{.ServiceNameVar}}.Email,
		Name:      {{.ServiceNameVar}}.Name,
		CreatedAt: {{.ServiceNameVar}}.CreatedAt.Unix(),
		UpdatedAt: {{.ServiceNameVar}}.UpdatedAt.Unix(),
	}
}

// normalizePage ensures page number is at least 1 for safe pagination.
//
// Parameters:
//   - page: requested page number (may be negative or zero)
//
// Returns:
//   - int: normalized page number (minimum 1)
//
// Concurrency:
//
//	Safe for concurrent use (pure function).
func normalizePage(page int) int {
	if page < 1 {
		return 1
	}
	return page
}

// normalizePageSize ensures page size is within valid range [1, 100].
//
// This function prevents:
//   - Excessive memory usage from large page sizes
//   - Invalid queries from zero or negative page sizes
//
// Parameters:
//   - pageSize: requested page size (may be any integer)
//
// Returns:
//   - int: normalized page size
//   - Returns 10 if pageSize < 1 (default)
//   - Returns 100 if pageSize > 100 (max)
//   - Returns pageSize otherwise
//
// Concurrency:
//
//	Safe for concurrent use (pure function).
func normalizePageSize(pageSize int) int {
	if pageSize < 1 {
		return 10 // default
	}
	if pageSize > 100 {
		return 100 // max
	}
	return pageSize
}
