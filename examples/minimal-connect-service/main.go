// Package main demonstrates a comprehensive Connect service using the egg framework.
//
// This example shows how to:
// - Set up a Connect service with unified interceptors
// - Use configx for configuration management with hot reloading
// - Integrate OpenTelemetry for observability
// - Use runtimex for lifecycle management
// - Handle graceful shutdown with proper error handling
// - Configure health and metrics endpoints
package main

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"connectrpc.com/connect"
	"github.com/eggybyte-technology/egg/configx"
	"github.com/eggybyte-technology/egg/connectx"
	"github.com/eggybyte-technology/egg/core/identity"
	"github.com/eggybyte-technology/egg/core/log"
	"github.com/eggybyte-technology/egg/obsx"
	"github.com/eggybyte-technology/egg/runtimex"
)

// SimpleLogger is a basic implementation of the log.Logger interface
type SimpleLogger struct{}

func (l *SimpleLogger) With(kv ...any) log.Logger {
	return l // Simple implementation - doesn't store context
}

func (l *SimpleLogger) Debug(msg string, kv ...any) {
	fmt.Printf("[DEBUG] %s %v\n", msg, kv)
}

func (l *SimpleLogger) Info(msg string, kv ...any) {
	fmt.Printf("[INFO] %s %v\n", msg, kv)
}

func (l *SimpleLogger) Warn(msg string, kv ...any) {
	fmt.Printf("[WARN] %s %v\n", msg, kv)
}

func (l *SimpleLogger) Error(err error, msg string, kv ...any) {
	if err != nil {
		fmt.Printf("[ERROR] %s: %v %v\n", msg, err, kv)
	} else {
		fmt.Printf("[ERROR] %s %v\n", msg, kv)
	}
}

// GreeterService implements a simple greeting service
type GreeterService struct{}

func (s *GreeterService) SayHello(ctx context.Context, req *connect.Request[HelloRequest]) (*connect.Response[HelloResponse], error) {
	// Extract user info from context if available
	if user, ok := identity.UserFrom(ctx); ok {
		logger.Info("User greeting request", log.Str("user_id", user.UserID))
	}

	name := req.Msg.Name
	if name == "" {
		name = "World"
	}

	response := &HelloResponse{
		Message: fmt.Sprintf("Hello, %s!", name),
	}

	return connect.NewResponse(response), nil
}

// Request and response types (normally generated by protoc-gen-connect-go)
type HelloRequest struct {
	Name string `json:"name"`
}

type HelloResponse struct {
	Message string `json:"message"`
}

// AppConfig extends BaseConfig with application-specific settings
type AppConfig struct {
	configx.BaseConfig

	// Application-specific configuration
	SlowRequestMillis int64 `env:"SLOW_REQUEST_MILLIS" default:"1000"`
	RateLimitQPS      int   `env:"RATE_LIMIT_QPS" default:"100"`
	EnableDebugLogs   bool  `env:"ENABLE_DEBUG_LOGS" default:"false"`
}

var logger log.Logger
var configManager configx.Manager

func main() {
	// Initialize logger
	logger = &SimpleLogger{}
	logger.Info("Starting comprehensive Connect service")

	// Create context for graceful shutdown
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Initialize configuration management
	var err error
	configManager, err = configx.DefaultManager(ctx, logger)
	if err != nil {
		logger.Error(err, "Failed to initialize configuration manager")
		os.Exit(1)
	}

	// Load application configuration
	var cfg AppConfig
	if err := configManager.Bind(&cfg); err != nil {
		logger.Error(err, "Failed to bind configuration")
		os.Exit(1)
	}

	logger.Info("Configuration loaded",
		log.Str("service_name", cfg.ServiceName),
		log.Str("service_version", cfg.ServiceVersion),
		log.Str("env", cfg.Env))

	// Set up configuration hot reloading
	configManager.OnUpdate(func(snapshot map[string]string) {
		logger.Info("Configuration updated", log.Int("keys", len(snapshot)))

		// Reload configuration
		var newCfg AppConfig
		if err := configManager.Bind(&newCfg); err != nil {
			logger.Error(err, "Failed to reload configuration")
			return
		}

		// Update application settings
		cfg = newCfg
		logger.Info("Configuration reloaded",
			log.Int("slow_request_millis", int(cfg.SlowRequestMillis)),
			log.Int("rate_limit_qps", cfg.RateLimitQPS))
	})

	// Initialize OpenTelemetry provider
	otel, err := obsx.NewProvider(ctx, obsx.Options{
		ServiceName:          cfg.ServiceName,
		ServiceVersion:       cfg.ServiceVersion,
		OTLPEndpoint:         cfg.OTLPEndpoint,
		EnableRuntimeMetrics: true,
		ResourceAttrs: map[string]string{
			"environment": cfg.Env,
			"instance":    getEnv("HOSTNAME", "unknown"),
		},
		TraceSamplerRatio: 0.1, // 10% sampling
	})
	if err != nil {
		logger.Error(err, "Failed to initialize OpenTelemetry provider")
		os.Exit(1)
	}
	defer func() {
		if err := otel.Shutdown(context.Background()); err != nil {
			logger.Error(err, "Failed to shutdown OpenTelemetry provider")
		}
	}()

	// Create HTTP mux
	mux := http.NewServeMux()

	// Set up Connect interceptors with configuration
	interceptors := connectx.DefaultInterceptors(connectx.Options{
		Logger:            logger,
		Otel:              otel,
		WithRequestBody:   cfg.EnableDebugLogs, // Enable only in debug mode
		WithResponseBody:  cfg.EnableDebugLogs, // Enable only in debug mode
		SlowRequestMillis: cfg.SlowRequestMillis,
		PayloadAccounting: true,
	})

	// Create Connect handler
	greeterService := &GreeterService{}
	handler := connect.NewUnaryHandler(
		"/greet.v1.GreeterService/SayHello",
		greeterService.SayHello,
		connect.WithInterceptors(interceptors...),
	)

	// Bind handler to mux
	connectx.Bind(mux, "/greet.v1.GreeterService/SayHello", handler)

	// Add a simple health check endpoint
	mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("OK"))
	})

	// Add a simple metrics endpoint
	mux.HandleFunc("/metrics", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("# Minimal metrics endpoint\n"))
	})

	// Set up graceful shutdown
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

	go func() {
		<-sigChan
		logger.Info("Received shutdown signal")
		cancel()
	}()

	// Start the runtime with configuration
	err = runtimex.Run(ctx, nil, runtimex.Options{
		Logger: logger,
		HTTP: &runtimex.HTTPOptions{
			Addr: cfg.HTTPPort,
			H2C:  true, // Enable HTTP/2 Cleartext
			Mux:  mux,
		},
		Health: &runtimex.Endpoint{
			Addr: cfg.HealthPort,
		},
		Metrics: &runtimex.Endpoint{
			Addr: cfg.MetricsPort,
		},
		ShutdownTimeout: 15 * time.Second,
	})

	if err != nil {
		logger.Error(err, "Runtime failed")
		os.Exit(1)
	}

	logger.Info("Service stopped gracefully")
}

// getEnv returns the value of an environment variable or a default value
func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}
